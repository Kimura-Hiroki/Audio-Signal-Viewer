<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>éŸ³å£°æ³¢å½¢è¡¨ç¤ºã‚¢ãƒ—ãƒª</title>
  <style>
    :root {
      --primary: #4CD964;
      --accent: #007AFF;
      --warn: #FF3B30;
      --bg: #f0f0f0;
      --fg: #111;
      --card: #fff;
    }
    body { margin: 0; padding: 1.5rem; background: var(--bg); color: var(--fg); font-family: -apple-system, BlinkMacSystemFont, sans-serif; display: flex; flex-direction: column; align-items: center; }
    @media (prefers-color-scheme: dark) { :root { --bg: #1a1a1a; --fg: #eee; --card: #222; } body { background: var(--bg); color: var(--fg); } }
    h1 { margin-bottom: 1rem; }
    .controls { display: flex; gap: 1rem; flex-wrap: wrap; justify-content: center; align-items: center; margin-bottom: 1rem; }
    select, button { padding: 0.6rem 1.2rem; border: none; border-radius: 8px; font-size: 1rem; cursor: pointer; }
    select { background: var(--card); color: var(--fg); }
    button { background: var(--primary); color: #fff; transition: background 0.3s; }
    button:hover:not(:disabled) { background: var(--accent); }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    #actionButton { background: var(--warn); }
    #pauseButton { background: #FFC107; color: var(--fg); }
    .slider-label { font-size: 1.2rem; }
    input[type=range] { width: 250px; accent-color: var(--accent); }
    canvas#waveform { width: 100%; max-width: 800px; height: 300px; background: var(--card); border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); margin-bottom: 1rem; }
    #digitalButton { margin-top: 0.5rem; }
    #digitalOutput { margin-top: 0.75rem; padding: 0.75rem; background: var(--card); border-radius: 8px; font-family: monospace; white-space: pre-wrap; max-width: 800px; word-break: break-all; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    footer { margin-top: 2rem; font-size: 0.8rem; color: var(--fg); opacity: 0.6; }
  </style>
</head>
<body>
  <h1>éŸ³å£°æ³¢å½¢è¡¨ç¤ºã‚¢ãƒ—ãƒª</h1>
  <div class="controls">
    <label>ãƒ¢ãƒ¼ãƒ‰: <select id="modeSelect">
      <option value="mic">ãƒã‚¤ã‚¯éŒ²éŸ³ãƒ¢ãƒ¼ãƒ‰</option>
      <option value="tone">é›»å­éŸ³ãƒ¢ãƒ¼ãƒ‰</option>
    </select></label>
  </div>
  <div class="controls">
    <button id="actionButton">éŒ²éŸ³é–‹å§‹</button>
    <button id="pauseButton" disabled>ä¸€æ™‚åœæ­¢</button>
  </div>
  <div class="controls">
    <span class="slider-label">ãƒ¼ğŸ”</span>
    <input type="range" id="zoomSlider" min="0" max="100" step="1" value="50">
    <span class="slider-label">ï¼‹ğŸ”</span>
  </div>
  <canvas id="waveform"></canvas>
  <button id="digitalButton">ãƒ‡ã‚¸ã‚¿ãƒ«åŒ–</button>
  <div id="digitalOutput"></div>
  <footer>Â©2025 ã‚­ãƒ ã‚Šã‚“ï¼ æ¾æœ¬æ·±å¿—é«˜æ ¡</footer>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // iOS touch/scroll/pinch ã§ã‚‚å†æç”»ã‚’ç¶™ç¶š
      ['scroll','touchmove','touchend','gesturechange','resize','orientationchange'].forEach(evt =>
        window.addEventListener(evt, () => { if(recording && !paused) draw(); }, { passive: true })
      );
      const modeSelect = document.getElementById('modeSelect');
      const actionBtn  = document.getElementById('actionButton');
      const pauseBtn   = document.getElementById('pauseButton');
      const zoomSlider = document.getElementById('zoomSlider');
      const digitalBtn = document.getElementById('digitalButton');
      const digitalOut = document.getElementById('digitalOutput');
      const canvas     = document.getElementById('waveform');
      const ctx        = canvas.getContext('2d');

      const QUANT_BITS = 8;
      const BUF_SIZE   = 2048;
      const MAX_LEN    = BUF_SIZE * 1000;
      const DIGITAL_MS = 10;

      let audioCtx, proc, micStream, osc, gainNode;
      let sampleRate = 44100;
      let buffer = [];
      let recording = false, paused = false;
      let zoom = 100;
      let showDigital = false;

      function initCanvas() { canvas.width = canvas.offsetWidth; canvas.height = canvas.offsetHeight; }
      window.addEventListener('resize', initCanvas); initCanvas();

      modeSelect.addEventListener('change', () => {
        stopAll(); buffer = [];
        recording = false; paused = false;
        actionBtn.disabled = false; pauseBtn.disabled = true;
        modeSelect.disabled = false;
        actionBtn.textContent = modeSelect.value === 'mic' ? 'éŒ²éŸ³é–‹å§‹' : 'å†ç”Ÿé–‹å§‹';
      });

      actionBtn.addEventListener('click', () => {
        if (recording && !paused) return;
        modeSelect.disabled = true;
        if (modeSelect.value === 'mic') startMic(); else startTone();
      });

      pauseBtn.addEventListener('click', () => {
        if (!recording) return;
        paused = !paused;
        pauseBtn.textContent = paused ? 'å†é–‹' : 'ä¸€æ™‚åœæ­¢';
        modeSelect.disabled = !paused && recording;
        if (modeSelect.value === 'tone' && gainNode) gainNode.gain.value = paused ? 0 : 1;
        if (!paused) draw();
      });

      zoomSlider.addEventListener('input', () => {
        const t = zoomSlider.value / 100;
        zoom = 100 * Math.pow(10, t);
        draw();
      });

      digitalBtn.addEventListener('click', () => {
        showDigital = !showDigital;
        digitalBtn.textContent = showDigital ? 'ãƒ‡ã‚¸ã‚¿ãƒ«åŒ–éè¡¨ç¤º' : 'ãƒ‡ã‚¸ã‚¿ãƒ«åŒ–';
        if (!showDigital) digitalOut.textContent = '';
        draw();
      });

      function stopAll() {
        if (proc) proc.disconnect();
        if (micStream) micStream.getTracks().forEach(t => t.stop());
        if (osc) osc.stop();
        if (audioCtx) audioCtx.close();
      }

      function startMic() {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)(); sampleRate = audioCtx.sampleRate;
        proc = audioCtx.createScriptProcessor(BUF_SIZE, 1, 1);
        navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
          micStream = stream;
          const src = audioCtx.createMediaStreamSource(stream);
          src.connect(proc); proc.connect(audioCtx.destination);
          proc.onaudioprocess = e => {
            if (paused) return;
            buffer.push(...e.inputBuffer.getChannelData(0));
            if (buffer.length > MAX_LEN) buffer.splice(0, buffer.length - MAX_LEN);
          };
          recording = true; paused = false;
          actionBtn.disabled = true; pauseBtn.disabled = false; pauseBtn.textContent = 'ä¸€æ™‚åœæ­¢';
          draw();
        }).catch(() => alert('ãƒã‚¤ã‚¯å…¥åŠ›ãŒè¨±å¯ã•ã‚Œã¦ã„ã¾ã›ã‚“'));
      }

      function startTone() {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)(); sampleRate = audioCtx.sampleRate;
        proc = audioCtx.createScriptProcessor(BUF_SIZE, 1, 1);
        osc = audioCtx.createOscillator(); gainNode = audioCtx.createGain();
        osc.type = 'sine'; osc.frequency.value = 440;
        osc.connect(gainNode); gainNode.connect(audioCtx.destination); gainNode.gain.value = 1;
        proc.connect(audioCtx.destination);
        gainNode.connect(proc);
        proc.onaudioprocess = e => {
          if (paused) return;
          buffer.push(...e.inputBuffer.getChannelData(0));
          if (buffer.length > MAX_LEN) buffer.splice(0, buffer.length - MAX_LEN);
        };
        recording = true; paused = false;
        actionBtn.disabled = true; pauseBtn.disabled = false; pauseBtn.textContent = 'ä¸€æ™‚åœæ­¢';
        osc.start(); draw();
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrid();
        const len = Math.min(buffer.length, Math.floor(MAX_LEN / zoom));
        const data = buffer.slice(-len);
        const w = canvas.width, h = canvas.height;
        const baseY = h / 2;
        // period width scaled by 1/3: show cycles 3x faster
        const step = len > w ? (len / 3) / w : 1/3;

        if (showDigital) {
          const seg = Math.min(Math.floor(sampleRate * DIGITAL_MS / 1000), len);
          const segW = (seg / len) * w;
          ctx.fillStyle = 'rgba(255,0,0,0.2)'; ctx.fillRect(w - segW, 0, segW, h);
          const maxVal = Math.pow(2, QUANT_BITS);
          const lines = [`ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°å‘¨æ³¢æ•°ï¼š${sampleRate}Hzï¼Œé‡å­åŒ–ãƒ“ãƒƒãƒˆæ•°ï¼š${QUANT_BITS}bit`];
          for (let i = 0; i < seg; i++) {
            const v = data[len - seg + i] || 0;
            const q = Math.floor((v + 1) / 2 * (maxVal - 1));
            const bin = q.toString(2).padStart(QUANT_BITS, '0');
            lines.push(`${bin} (${q})`);
          }
          digitalOut.textContent = lines.join('\n');
        }

        ctx.beginPath(); ctx.strokeStyle = 'var(--accent)'; ctx.lineWidth = 2;
        ctx.moveTo(0, baseY);
        for (let x = 0; x < w; x++) {
          const v = data[Math.floor(x * step)] || 0;
          ctx.lineTo(x, baseY - v * baseY);
        }
        ctx.stroke();

        if (recording && !paused) requestAnimationFrame(draw);
      }

      function drawGrid() {
        const w = canvas.width, h = canvas.height;
        ctx.strokeStyle = '#ccc'; ctx.lineWidth = 0.5;
        for (let y = 0; y <= h; y += h / 4) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke(); }
        for (let x = 0; x <= w; x += w / 10) {
          ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
          const t = ((x / w) * (MAX_LEN / zoom) / sampleRate * 1000).toFixed(0);
          ctx.fillStyle = 'var(--fg)'; ctx.font = '10px sans-serif'; ctx.textAlign = 'center'; ctx.fillText(`${t}ms`, x, h - 5);
        }
      }
    });
  </script>
</body>
</html>
